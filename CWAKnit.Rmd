---
title: "CWA"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
source("CWA2020code.R")
suppressPackageStartupMessages(library(tidyverse))
theme_set(theme_bw())
filament <- read.csv("filament.csv", stringsAsFactors = FALSE)
```

## Task 1

Plot the CAD and Actual weight data, with matching colours for each material.

```{r}

ggplot(filament) +
  geom_point(aes(CAD_Weight, Actual_Weight, col = Material)) +
  scale_color_manual(values = c(Black = "black",
                                Red = "red",
                                Green = "green",
                                Magenta = "magenta",
                                "Neon pink" = "#fca3b7",
                                "Neon blue"= "#1b03a3"))



```

## Task 2

Unlike lab 3, the model Z function in CWA2020code.R now takes more
arguments, allowing more exibility in how to dene the models. De-
ne a function model estimate that takes parameters formulas, data,
response, where formulas and data have the same interpretation as the
input arguments to model Z, 

and response is a character/string variable
naming the response (measured outcome) variable column of the data.


The function should estimate the model by numerical optimisation, and re-
turn a list with three named elements: theta, formulas, and Sigma theta,
containing the information needed to call the model predict function.


```{r}
model_estimate <- function(formulas, data, response){
  
  Z_2=model_Z(formulas,data)
  
  opt <- optim(rep(0, ncol(Z_2[["ZE"]])),
               fn = neg_log_lik,
               Z = Z_2, 
               y = data[[response]],
               method = "BFGS",
               control = list(maxit = 5000),
               hessian = TRUE)
  
  theta <- opt$par
  Sigma_theta <- solve(opt$hessian)
  
  formulas1=formulas
  
  return (list(theta = theta, formulas = formulas1, Sigma_theta=Sigma_theta))
  
  }
```

## Task 3

3. Estimate a model for Actual Weight 
with an intercept and covariate CAD_Weight for the model expectations,

but only an intercept for the model (log-)variances. 


```{r}
data_obs <- filament[filament$Class=="obs",]

formulas_3 <- list(E = ~ 1 + CAD_Weight, V = ~ 1)

estimates_3 <- model_estimate(formulas_3, data_obs, "Actual_Weight")

estimates_3

```

```{r}
rbind(range(diag(estimates_3$Sigma_theta)))
#correct answer
```

## Task 4

Plot the test data together with the prediction intervals for the estimated
model from task 3.


```{r}

data_test <- filament[filament$Class=="test",]


model3 <- model_predict(estimates_3[["theta"]], estimates_3[["formulas"]], estimates_3[["Sigma_theta"]],data_test,type="observation")


pred_plot_4 <- cbind(data_test, model3)

ggplot() +
  geom_ribbon(data = pred_plot_4,
              aes(CAD_Weight, ymin = lwr, ymax = upr),
              alpha = 0.25, fill = "blue") +
  geom_line(data = pred_plot_4, aes(CAD_Weight, mu), col = "blue") +
  geom_point(data = data_test, aes(CAD_Weight, Actual_Weight), col = "magenta")


```


## Task 5

5. Now estimate a model that uses an intercept and covariate CAD Weight formula for both the model expectations and (log-)variances.

```{r}
formulas_5 <- list(E = ~ 1 + CAD_Weight, V = ~ 1+ CAD_Weight)

estimates_5 <- model_estimate(formulas_5, data_obs, "Actual_Weight")

estimates_5

```


```{r}
rbind(range(diag(estimates_5$Sigma_theta)))
#correct answer
```


## Task 6

6. Plot the test data together with the prediction intervals for the two estimated models from tasks 3 and 5.

```{r}

model5 <- model_predict(estimates_5[["theta"]], estimates_5[["formulas"]], estimates_5[["Sigma_theta"]],data_test,type="observation")


pred_plot_6 <- cbind(data_test, model5)

ggplot() +
  geom_ribbon(data = pred_plot_4,
              aes(CAD_Weight, ymin = lwr, ymax = upr),
              alpha = 0.25, fill = "blue") +
  geom_ribbon(data = pred_plot_6,
              aes(CAD_Weight, ymin = lwr, ymax = upr),
              alpha = 0.25, fill = "red") +
  geom_line(data = pred_plot_4, aes(CAD_Weight, mu), col = "blue") +
  geom_line(data = pred_plot_6, aes(CAD_Weight, mu), col = "red") +
  geom_point(data = data_test, aes(CAD_Weight, Actual_Weight), col = "black")


```

## Task 7

7. Compute the Squared Error, Dawid-Sebastiani, and Interval scores (alpha =
0.1) for the two estimated models. Consider the collections of pairwise
score differences of each score type. Do the scores agree about which
model seems better?

Hint: Write a function model scores with suitable input and output pa-
rameters to avoid unneccessary code repeating.

```{r}
model_scores <- function (modelQ, data, response, alpha){
  
  
return(data.frame(
  SES=c((score_se(modelQ, data[[response]]))),
  DSS=c((score_ds(modelQ, data[[response]]))),
  IS=c((score_interval(modelQ, data[[response]], alpha = alpha)))
))  
  
}



Score_3 = model_scores(model3, data_test, 'Actual_Weight', 0.1)
Score_5 = model_scores(model5, data_test, 'Actual_Weight', 0.1)

S5_S3 = Score_5 - Score_3


plot(ecdf(S5_S3[["SES"]]),
     xlim=c(-8,5),
      xlab="Score Difference (Score 5 - Score 3)",
      ylab="ecdf",
      main="Empirical CDF of Difference between Scores of Model 5 and Model 3",
      col="black")
lines(ecdf(S5_S3[["DSS"]]),
     col="blue")
lines(ecdf(S5_S3[["IS"]]),
     col="purple")

legend('bottomright', 
       legend=c("Squared Error","Dawid-Sebastiani","Interval Score"),
       col=c("black","blue","purple"),
       pch=15)


```

The ecdf is largely skewed towards the negative end which means that Model 5 performs significantly better than Model 3.



## Task 8

The printer user wonders if the CAD system is equally (or bad) at pre-
dicting the weight of all the different materials. Estimate a model with
material dependent CAD Weight coefficients for the expectation part of the
model, and compare the prediction scores with those from task 7.

Hint: Find out what the interaction syntax A:B does in a model formula,
when A is a factor and B is a continuous variable.

```{r}

formulas_8 <- list(E = ~ 1 + CAD_Weight:Material, V = ~ 1+ CAD_Weight)

estimates_8 <- model_estimate(formulas_8, data_obs, "Actual_Weight")

estimates_8
```
```{r}
model8 <- model_predict(estimates_8[["theta"]], estimates_8[["formulas"]], estimates_8[["Sigma_theta"]],data_test,type="observation")


Score_8 = model_scores(model8, data_test, 'Actual_Weight', 0.1)

S8_S3 = Score_8 - Score_3

plot(ecdf(S8_S3[["SES"]]),
     xlim=c(-8,5),
      xlab="Score Difference (Score 8 - Score 3)",
      ylab="ecdf",
      main="Empirical CDF of Difference between Scores of Model 8 and Model 3",
      col="seashell2")
lines(ecdf(S8_S3[["DSS"]]),
     col="khaki")
lines(ecdf(S8_S3[["IS"]]),
     col="purple")

legend('bottomright', 
       legend=c("Squared Error","Dawid-Sebastiani","Interval Score"),
       col=c("seashell2","khaki","purple"),
       pch=15)

```

```{r}
rbind(range(diag(estimates_8$Sigma_theta)))
#correct answer
```


## Task 9

```{r}

Prob_3 = pnorm(q=1.1*data_test$CAD_Weight,mean = model3$mu,sd = model3$sigma,lower.tail = FALSE)
Prob_5 = pnorm(q=1.1*data_test$CAD_Weight,mean = model5$mu,sd = model5$sigma,lower.tail = FALSE)
Prob_8 = pnorm(q=1.1*data_test$CAD_Weight,mean = model8$mu,sd = model8$sigma,lower.tail = FALSE)

Prob_CAD=cbind(Prob_3,Prob_5,Prob_8,data_test)


ggplot() +
  geom_point(data=Prob_CAD,aes(CAD_Weight,Prob_3, col = "Model 3" )) +
  geom_point(data=Prob_CAD,aes(CAD_Weight,Prob_5, col = "Model 5")) +
  geom_line(data=Prob_CAD,aes(CAD_Weight,Prob_3, col = "Model 3" )) +
  geom_line(data=Prob_CAD,aes(CAD_Weight,Prob_5, col = "Model 5")) +
  geom_point(data=Prob_CAD,aes(CAD_Weight,Prob_8, col = "Model 8")) +
  #theme(legend.position="right") +
  labs(subtitle="Event: More than 10% extra weight is needed compared with CAD_Weight", 
       y="Probability", 
       x="CAD_Weight", 
       title="Probabilities for the Event for each Model", 
       caption = "Note: Probabilities for Model 8 shown as Scatter plot only")
  

score_brier <- function (z, probF){
  (z - probF)^2
}

# if Actual_Weight "<\>" 1.1*CAD_Weight then z=1 otherwise z=0
indicator<- ifelse(data_test$Actual_Weight>data_test$CAD_Weight*1.1,1,0)


BS_3=c((score_brier(indicator,Prob_3)))
BS_5=c((score_brier(indicator,Prob_5)))
BS_8=c((score_brier(indicator,Prob_8)))

# print("Brier Scores for Model 3")
# BS_3
# print("Brier Scores for Model 5")
# BS_5
# print("Brier Scores for Model 8")
# BS_8

df.brier=data.frame("Brier Score for Model 3"=BS_3,"Brier Score for Model 5"=BS_5,"Brier Score for Model 8"=BS_8)

B5_B3 = BS_5-BS_3
B8_B3 = BS_8-BS_3


plot(ecdf(B8_B3),
     #xlim=c(-8,5),
      xlab="Score Difference (Score 8 - Score 3)",
      ylab="ecdf",
      main="Empirical CDF of Difference between Scores of Model 8 and Model 3",
      col="red")
lines(ecdf(B5_B3),
     col="blue")

legend('bottomright', 
       legend=c("Model 8 - Model 3","Model 5 - Model 3"),
       col=c("red","blue"),
       pch=15)


data.frame(Prob_3,Prob_5,Prob_8)

```

## Task 10

```{r}

```



